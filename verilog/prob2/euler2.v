module euler2(
	      input logic 	  clk,
	      input logic 	  reset,
	      input logic 	  enable,
	      input logic [31:0] MAX_VALUE,
	      output logic 	  results_valid,
	      output logic [31:0] results
	      );
   
//Each new term in the Fibonacci sequence is generated by adding the
//  previous two terms. By starting with 1 and 2, the first 10 terms will be:
//
//1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
//By considering the terms in the Fibonacci sequence whose values
//  do not exceed four million, find the sum of the even-valued terms.

   // 1 fibonacci
   // 2 even terms
   // 3 sum them
   // 4 don't exceed term value = X
   logic [31:0] fib1 = 1;
   logic [31:0] fib2 = 2;
   logic [31:0] sum = 0;
   //logic [31:0] fib3; what insanity is this? this gets the error "cannot be driven by primitives or continuous assignment?
   wire [31:0] 	fib3;
   

   //iverilog's error messages are terrible. switch the order of
   // clk and posedge, and you get the messages:
   // syntax error
   // error: Malformed event control expression.
   // error: Invalid event control.

   assign fib3 = fib2 + fib1;
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 fib1 <= 1;
	 fib2 <= 2;
	 //sum <= 2; // this feels a little like cheating,
	 // but it saves us a clock cycle to just set it here.
	 // alternatively, the logic below is summing fib2 vs fib3
	 sum <= 0;
	 results_valid <= 0;
	 // it's super easy to forget when to use
	 // = or <=. this seems like a problem, though
	 // i don't think i've found it to be one at work. 
      end else if (enable == 1 && results_valid == 0) begin
	 if (fib2[0] == 0)
	   sum <= sum + fib2;
	 fib2 <= fib3;
	 fib1 <= fib2;
	 if (fib2 >= MAX_VALUE) begin
	    results <= sum;
	    results_valid <= 1;
	 end else begin
	    results_valid <= 0;
	 end
      end
   end

   // if you don't have an endmodule, you'll get an error message on the
   // next file evalulated, which isn't very helpful. 
endmodule // euler2
